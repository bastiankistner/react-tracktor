(window.webpackJsonp=window.webpackJsonp||[]).push([[4],{"./docs/Tracktor.mdx":function(e,t,n){"use strict";n.r(t),n.d(t,"default",function(){return d});var r=n("./node_modules/babel-preset-react-app/node_modules/@babel/runtime/helpers/esm/objectWithoutProperties.js"),a=(n("./node_modules/react/index.js"),n("./node_modules/@mdx-js/react/dist/index.es.js")),i=n("./node_modules/docz/dist/index.esm.js"),c=n("./src/Tracktor.tsx"),o=n("./src/TracktorProvider.tsx"),b={},l="wrapper";function d(e){var t=e.components,n=Object(r.a)(e,["components"]);return Object(a.b)(l,Object.assign({},b,n,{components:t,mdxType:"MDXLayout"}),Object(a.b)("h1",{id:"tracktor-"},Object(a.b)("inlineCode",{parentName:"h1"},"<Tracktor />")),Object(a.b)("p",null,"This is the main render-prop that can be used to gradually build the tracking data.\nIt needs to be wrapped in ",Object(a.b)("strong",{parentName:"p"},"one")," top-level ",Object(a.b)("inlineCode",{parentName:"p"},"<TracktorProvider />")," per render-tree which defines a ",Object(a.b)("inlineCode",{parentName:"p"},"dispatcher")," function that recieves the ",Object(a.b)("inlineCode",{parentName:"p"},"trackingData")," and does something with it.\nSee the ",Object(a.b)("inlineCode",{parentName:"p"},"<TracktorProvider />")," section for details."),Object(a.b)("h2",{id:"props"},"Props"),Object(a.b)("h3",{id:"tracktor--props"},Object(a.b)("inlineCode",{parentName:"h3"},"<Tracktor />")," Props"),Object(a.b)("table",null,Object(a.b)("thead",{parentName:"table"},Object(a.b)("tr",{parentName:"thead"},Object(a.b)("th",Object.assign({parentName:"tr"},{align:null}),"Name"),Object(a.b)("th",Object.assign({parentName:"tr"},{align:null}),"Type"),Object(a.b)("th",Object.assign({parentName:"tr"},{align:null}),"Default"),Object(a.b)("th",Object.assign({parentName:"tr"},{align:null}),"Description"))),Object(a.b)("tbody",{parentName:"table"},Object(a.b)("tr",{parentName:"tbody"},Object(a.b)("td",Object.assign({parentName:"tr"},{align:null}),Object(a.b)("inlineCode",{parentName:"td"},"eventData")),Object(a.b)("td",Object.assign({parentName:"tr"},{align:null}),Object(a.b)("em",{parentName:"td"},"object")),Object(a.b)("td",Object.assign({parentName:"tr"},{align:null}),Object(a.b)("inlineCode",{parentName:"td"},"{}")),Object(a.b)("td",Object.assign({parentName:"tr"},{align:null}),"An object with tracking data that should be provided to the ",Object(a.b)("inlineCode",{parentName:"td"},"dispatcher")," when the ",Object(a.b)("inlineCode",{parentName:"td"},"onClickWrapper")," is fired or (when using the ",Object(a.b)("inlineCode",{parentName:"td"},"intersectionRef")," or ",Object(a.b)("inlineCode",{parentName:"td"},"intersectionWrapper"),") the component scrolls into view.")),Object(a.b)("tr",{parentName:"tbody"},Object(a.b)("td",Object.assign({parentName:"tr"},{align:null}),Object(a.b)("inlineCode",{parentName:"td"},"intersectionOptions")),Object(a.b)("td",Object.assign({parentName:"tr"},{align:null}),Object(a.b)("em",{parentName:"td"},"object")),Object(a.b)("td",Object.assign({parentName:"tr"},{align:null}),Object(a.b)("inlineCode",{parentName:"td"},"{ triggerOnce: true }")),Object(a.b)("td",Object.assign({parentName:"tr"},{align:null}),"Options passed to the IntersectionObserver. ",Object(a.b)("br",null),"See: ",Object(a.b)("a",Object.assign({parentName:"td"},{href:"https://github.com/thebuilder/react-intersection-observer#options"}),"https://github.com/thebuilder/react-intersection-observer#options"))),Object(a.b)("tr",{parentName:"tbody"},Object(a.b)("td",Object.assign({parentName:"tr"},{align:null}),Object(a.b)("inlineCode",{parentName:"td"},"render")),Object(a.b)("td",Object.assign({parentName:"tr"},{align:null}),Object(a.b)("inlineCode",{parentName:"td"},"(value: TracktorRenderProp) => ReactNode")),Object(a.b)("td",Object.assign({parentName:"tr"},{align:null}),Object(a.b)("em",{parentName:"td"},"required")),Object(a.b)("td",Object.assign({parentName:"tr"},{align:null}),"The render function")),Object(a.b)("tr",{parentName:"tbody"},Object(a.b)("td",Object.assign({parentName:"tr"},{align:null}),Object(a.b)("inlineCode",{parentName:"td"},"trackingData")),Object(a.b)("td",Object.assign({parentName:"tr"},{align:null}),Object(a.b)("em",{parentName:"td"},"object")),Object(a.b)("td",Object.assign({parentName:"tr"},{align:null}),Object(a.b)("inlineCode",{parentName:"td"},"{}")),Object(a.b)("td",Object.assign({parentName:"tr"},{align:null}),"An object with data that should be used when tracking events from this component and all components further down the render tree.")))),Object(a.b)("h3",{id:"render-props"},Object(a.b)("inlineCode",{parentName:"h3"},"render")," Props"),Object(a.b)("table",null,Object(a.b)("thead",{parentName:"table"},Object(a.b)("tr",{parentName:"thead"},Object(a.b)("th",Object.assign({parentName:"tr"},{align:null}),"Name"),Object(a.b)("th",Object.assign({parentName:"tr"},{align:null}),"Type"),Object(a.b)("th",Object.assign({parentName:"tr"},{align:null}),"Description"))),Object(a.b)("tbody",{parentName:"table"},Object(a.b)("tr",{parentName:"tbody"},Object(a.b)("td",Object.assign({parentName:"tr"},{align:null}),Object(a.b)("inlineCode",{parentName:"td"},"intersectionRef")),Object(a.b)("td",Object.assign({parentName:"tr"},{align:null}),Object(a.b)("em",{parentName:"td"},"ReactRef")),Object(a.b)("td",Object.assign({parentName:"tr"},{align:null}),"If used as a ref for a DOM element, a ",Object(a.b)("inlineCode",{parentName:"td"},"trackEvent")," will be fired with the the provided ",Object(a.b)("inlineCode",{parentName:"td"},"eventData")," when the refed element scrolls into view.")),Object(a.b)("tr",{parentName:"tbody"},Object(a.b)("td",Object.assign({parentName:"tr"},{align:null}),Object(a.b)("inlineCode",{parentName:"td"},"intersectionWrapper")),Object(a.b)("td",Object.assign({parentName:"tr"},{align:null}),Object(a.b)("inlineCode",{parentName:"td"},"(WrappedComponent: ReactNode) => ReactNode)")),Object(a.b)("td",Object.assign({parentName:"tr"},{align:null}),"Can be used to wrap a component to inject an invisibile ",Object(a.b)("inlineCode",{parentName:"td"},"<div />")," which will have the ",Object(a.b)("inlineCode",{parentName:"td"},"intersectionRef")," and track on intersection.")),Object(a.b)("tr",{parentName:"tbody"},Object(a.b)("td",Object.assign({parentName:"tr"},{align:null}),Object(a.b)("inlineCode",{parentName:"td"},"onClickWrapper")),Object(a.b)("td",Object.assign({parentName:"tr"},{align:null}),Object(a.b)("inlineCode",{parentName:"td"},"(trackEventData: object) => () => void")),Object(a.b)("td",Object.assign({parentName:"tr"},{align:null}),"Can be used to wrap a component's ",Object(a.b)("inlineCode",{parentName:"td"},"onClick")," prop, the returning function, also fires an ",Object(a.b)("inlineCode",{parentName:"td"},"trackEvent"),".")),Object(a.b)("tr",{parentName:"tbody"},Object(a.b)("td",Object.assign({parentName:"tr"},{align:null}),Object(a.b)("inlineCode",{parentName:"td"},"trackEvent")),Object(a.b)("td",Object.assign({parentName:"tr"},{align:null}),Object(a.b)("inlineCode",{parentName:"td"},"(trackEventData: object) => void")),Object(a.b)("td",Object.assign({parentName:"tr"},{align:null}),"Function which fires an ",Object(a.b)("inlineCode",{parentName:"td"},"trackEvent")," with the provided data, merged with all previously provided ",Object(a.b)("inlineCode",{parentName:"td"},"trackingData"),".")))),Object(a.b)("h2",{id:"usage"},"Usage"),Object(a.b)("p",null,Object(a.b)("em",{parentName:"p"},"Open the console to see tracking events")," & ",Object(a.b)("em",{parentName:"p"},"Click the ",Object(a.b)("inlineCode",{parentName:"em"},"<>")," to see the code.")),Object(a.b)("h3",{id:"trackevent"},Object(a.b)("inlineCode",{parentName:"h3"},"trackEvent")),Object(a.b)("p",null,"Normally these would be spread out throughout different pages and components."),Object(a.b)(i.c,{__position:0,__code:"<TracktorProvider dispatcher={trackingData => console.log(trackingData)}>\n  <Tracktor\n    trackingData={{ page: 'Tracktor.mdx' }}\n    render={() => (\n      <main>\n        <h2>Tracktor.mdx</h2>\n        <Tracktor\n          trackingData={{ section: 'basic_usage' }}\n          render={({ trackEvent }) => (\n            <section>\n              <h3>\n                <code>trackEvent</code>\n              </h3>\n\n              <button onClick={() => trackEvent({ button: 'hello' })}>\n                Hello\n              </button>\n\n              <button onClick={() => trackEvent({ button: 'goodbye' })}>\n                Goodbye\n              </button>\n            </section>\n          )}\n        />\n      </main>\n    )}\n  />\n</TracktorProvider>",__scope:{props:this?this.props:n,Playground:i.c,Tracktor:c.a,TracktorProvider:o.a},mdxType:"Playground"},Object(a.b)(o.a,{dispatcher:function(e){return console.log(e)},mdxType:"TracktorProvider"},Object(a.b)(c.a,{trackingData:{page:"Tracktor.mdx"},render:function(){return Object(a.b)("main",null,Object(a.b)("h2",null,"Tracktor.mdx"),Object(a.b)(c.a,{trackingData:{section:"basic_usage"},render:function(e){var t=e.trackEvent;return Object(a.b)("section",null,Object(a.b)("h3",null,Object(a.b)("code",null,"trackEvent")),Object(a.b)("button",{onClick:function(){return t({button:"hello"})}},"Hello"),Object(a.b)("button",{onClick:function(){return t({button:"goodbye"})}},"Goodbye"))},mdxType:"Tracktor"}))},mdxType:"Tracktor"}))),Object(a.b)("h3",{id:"onclickwrapper"},Object(a.b)("inlineCode",{parentName:"h3"},"onClickWrapper")),Object(a.b)("p",null,Object(a.b)("inlineCode",{parentName:"p"},"render")," provides a ",Object(a.b)("inlineCode",{parentName:"p"},"onClickWrapper")," to wrap existing ",Object(a.b)("inlineCode",{parentName:"p"},"onClick")," functions to also trigger an tracking event with the provided ",Object(a.b)("inlineCode",{parentName:"p"},"eventData"),"."),Object(a.b)(i.c,{__position:1,__code:"<TracktorProvider dispatcher={trackingData => console.log(trackingData)}>\n  <Tracktor\n    trackingData={{ page: 'Tracktor.mdx' }}\n    render={() => (\n      <main>\n        <h2>Tracktor.mdx</h2>\n        <Tracktor\n          trackingData={{ section: 'on-click_wrapper' }}\n          eventData={{ button: 'click_me' }}\n          render={({ onClickWrapper }) => {\n            const existingOnClickFunction = () =>\n              console.log(\n                'This is a `console.log` from an existing `onClick` function.',\n              )\n\n            return (\n              <section>\n                <h3>\n                  <code>onClickWrapper</code>\n                </h3>\n\n                <button onClick={onClickWrapper(existingOnClickFunction)}>\n                  Click Me\n                </button>\n              </section>\n            )\n          }}\n        />\n      </main>\n    )}\n  />\n</TracktorProvider>",__scope:{props:this?this.props:n,Playground:i.c,Tracktor:c.a,TracktorProvider:o.a},mdxType:"Playground"},Object(a.b)(o.a,{dispatcher:function(e){return console.log(e)},mdxType:"TracktorProvider"},Object(a.b)(c.a,{trackingData:{page:"Tracktor.mdx"},render:function(){return Object(a.b)("main",null,Object(a.b)("h2",null,"Tracktor.mdx"),Object(a.b)(c.a,{trackingData:{section:"on-click_wrapper"},eventData:{button:"click_me"},render:function(e){var t=e.onClickWrapper;return Object(a.b)("section",null,Object(a.b)("h3",null,Object(a.b)("code",null,"onClickWrapper")),Object(a.b)("button",{onClick:t(function(){return console.log("This is a `console.log` from an existing `onClick` function.")})},"Click Me"))},mdxType:"Tracktor"}))},mdxType:"Tracktor"}))),Object(a.b)("h3",{id:"intersectionref"},Object(a.b)("inlineCode",{parentName:"h3"},"intersectionRef")),Object(a.b)("p",null,Object(a.b)("inlineCode",{parentName:"p"},"render")," provides a ",Object(a.b)("inlineCode",{parentName:"p"},"ref={intersectionRef}")," that can be put on to DOM elements to trigger an tracking event with the provided ",Object(a.b)("inlineCode",{parentName:"p"},"eventData"),". Like with ",Object(a.b)("inlineCode",{parentName:"p"},"trackEvent"),", the data from all ",Object(a.b)("inlineCode",{parentName:"p"},"<Tracktor />")," components above in the render tree will be merged with the ",Object(a.b)("inlineCode",{parentName:"p"},"eventData")," when the tracking event fires."),Object(a.b)(i.c,{__position:2,__code:"<TracktorProvider dispatcher={trackingData => console.log(trackingData)}>\n  <Tracktor\n    trackingData={{ page: 'Tracktor.mdx' }}\n    render={() => (\n      <main>\n        <h2>Tracktor.mdx</h2>\n        <Tracktor\n          trackingData={{ section: 'intersection_ref' }}\n          eventData={{ intersected: true }}\n          render={({ intersectionRef }) => (\n            <section>\n              <h3>\n                <code>intersectionRef</code>\n              </h3>\n\n              <p ref={intersectionRef}>\n                When this scrolled into view, we fired a tracking event with\n                the data defined in `eventData`.\n              </p>\n            </section>\n          )}\n        />\n      </main>\n    )}\n  />\n</TracktorProvider>",__scope:{props:this?this.props:n,Playground:i.c,Tracktor:c.a,TracktorProvider:o.a},mdxType:"Playground"},Object(a.b)(o.a,{dispatcher:function(e){return console.log(e)},mdxType:"TracktorProvider"},Object(a.b)(c.a,{trackingData:{page:"Tracktor.mdx"},render:function(){return Object(a.b)("main",null,Object(a.b)("h2",null,"Tracktor.mdx"),Object(a.b)(c.a,{trackingData:{section:"intersection_ref"},eventData:{intersected:!0},render:function(e){var t=e.intersectionRef;return Object(a.b)("section",null,Object(a.b)("h3",null,Object(a.b)("code",null,"intersectionRef")),Object(a.b)("p",{ref:t},"When this scrolled into view, we fired a tracking event with the data defined in `eventData`."))},mdxType:"Tracktor"}))},mdxType:"Tracktor"}))),Object(a.b)("h3",{id:"intersectionwrapper"},Object(a.b)("inlineCode",{parentName:"h3"},"intersectionWrapper")),Object(a.b)("p",null,Object(a.b)("inlineCode",{parentName:"p"},"render")," provides a ",Object(a.b)("inlineCode",{parentName:"p"},"intersectionWrapper")," that can be wrapped around JSX that injects an invisible ",Object(a.b)("inlineCode",{parentName:"p"},"<div />")," with the ",Object(a.b)("inlineCode",{parentName:"p"},"intersectionRef")," as it's reference."),Object(a.b)(i.c,{__position:3,__code:"<TracktorProvider dispatcher={trackingData => console.log(trackingData)}>\n  <Tracktor\n    trackingData={{ page: 'Tracktor.mdx' }}\n    render={() => (\n      <main>\n        <h2>Tracktor.mdx</h2>\n        <Tracktor\n          trackingData={{ section: 'intersection_wrapper' }}\n          eventData={{ intersected: true }}\n          render={({ intersectionWrapper }) =>\n            intersectionWrapper(\n              <section>\n                <h3>\n                  <code>intersectionWrapper</code>\n                </h3>\n\n                <p>\n                  When this scrolled into view, we fired a tracking event with\n                  the data defined in `eventData`.\n                </p>\n              </section>,\n            )\n          }\n        />\n      </main>\n    )}\n  />\n</TracktorProvider>",__scope:{props:this?this.props:n,Playground:i.c,Tracktor:c.a,TracktorProvider:o.a},mdxType:"Playground"},Object(a.b)(o.a,{dispatcher:function(e){return console.log(e)},mdxType:"TracktorProvider"},Object(a.b)(c.a,{trackingData:{page:"Tracktor.mdx"},render:function(){return Object(a.b)("main",null,Object(a.b)("h2",null,"Tracktor.mdx"),Object(a.b)(c.a,{trackingData:{section:"intersection_wrapper"},eventData:{intersected:!0},render:function(e){return(0,e.intersectionWrapper)(Object(a.b)("section",null,Object(a.b)("h3",null,Object(a.b)("code",null,"intersectionWrapper")),Object(a.b)("p",null,"When this scrolled into view, we fired a tracking event with the data defined in `eventData`.")))},mdxType:"Tracktor"}))},mdxType:"Tracktor"}))))}d&&d===Object(d)&&Object.isExtensible(d)&&Object.defineProperty(d,"__filemeta",{enumerable:!0,configurable:!0,value:{name:"MDXContent",filename:"docs/Tracktor.mdx"}}),d.isMDXComponent=!0},"./src/Tracktor.tsx":function(e,t,n){"use strict";var r=n("./node_modules/babel-preset-react-app/node_modules/@babel/runtime/helpers/esm/objectSpread.js"),a=n("./node_modules/babel-preset-react-app/node_modules/@babel/runtime/helpers/esm/slicedToArray.js"),i=n("./node_modules/react/index.js"),c=n.n(i),o={height:0,visibility:"hidden",width:0},b=c.a.forwardRef(function(e,t){var n=e.children;return c.a.createElement(c.a.Fragment,null,n,c.a.createElement("div",{"aria-hidden":!0,ref:t,style:o}))}),l=b;"undefined"!==typeof b&&b&&b===Object(b)&&Object.isExtensible(b)&&Object.defineProperty(b,"__filemeta",{enumerable:!0,configurable:!0,value:{name:"IntersectionComponent",filename:"src/IntersectionComponent.tsx"}});var d=n("./node_modules/deepmerge/dist/umd.js"),s=n.n(d),p=function(){try{for(var e=arguments.length,t=new Array(e),n=0;n<e;n++)t[n]=arguments[n];return s.a.all(t)}catch(r){throw console.error(r),Error("Couldn't parse `trackingData`. Did you try to pass `trackEvent` to an `onClick` handler directly? Try `onClick={() => trackEvent({})` instead of `onClick={trackEvent}`.")}},u=p;p&&p===Object(p)&&Object.isExtensible(p)&&Object.defineProperty(p,"__filemeta",{enumerable:!0,configurable:!0,value:{name:"computeTrackingData",filename:"src/utils/computeTrackingData.ts"}});var m=n("./node_modules/react-intersection-observer/react-intersection-observer.esm.js"),j=function(e){var t=e.callback,n=e.options,r=void 0===n?{}:n,i=Object(m.a)(r),o=Object(a.a)(i,2),b=o[0],l=o[1];return c.a.useEffect(function(){l&&t()},[t,l]),[b,l]},O=j;j&&j===Object(j)&&Object.isExtensible(j)&&Object.defineProperty(j,"__filemeta",{enumerable:!0,configurable:!0,value:{name:"useOnIntersect",filename:"src/utils/useOnIntersect.ts"}});var h=function(e){return function(t){return function(){return e(),t.apply(void 0,arguments)}}},g=h;h&&h===Object(h)&&Object.isExtensible(h)&&Object.defineProperty(h,"__filemeta",{enumerable:!0,configurable:!0,value:{name:"wrapFunction",filename:"src/utils/wrapFunction.ts"}});var k=n("./src/TracktorContext.ts"),f=function(e){var t=e.eventData,n=e.intersectionOptions,i=void 0===n?{triggerOnce:!0}:n,o=e.render,b=e.trackingData,d=void 0===b?{}:b,s=c.a.useState(k.b),p=Object(a.a)(s,2),m=p[0],j=p[1],h=function(){var e=arguments.length>0&&void 0!==arguments[0]?arguments[0]:{},t=arguments.length>1&&void 0!==arguments[1]?arguments[1]:{},n=m.dispatcher;if(t.withoutContext)return n(e);n(u(m.data,d,e||{}))},f=g(function(){var e=arguments.length>0&&void 0!==arguments[0]?arguments[0]:{};return function(){h(e||{})}}(t)),v=O({callback:function(){h(t||{})},options:i}),N=Object(a.a)(v,1)[0],T=function(e){return c.a.createElement(l,{ref:N},e)};return c.a.createElement(k.a.Consumer,null,function(e){j(e);var t=Object(r.a)({},e,{data:u(e.data,d)});return c.a.createElement(k.a.Provider,{value:t},o({intersectionRef:N,intersectionWrapper:T,onClickWrapper:f,trackEvent:h}))})};t.a=f;f&&f===Object(f)&&Object.isExtensible(f)&&Object.defineProperty(f,"__filemeta",{enumerable:!0,configurable:!0,value:{name:"Tracktor",filename:"src/Tracktor.tsx"}})},"./src/TracktorContext.ts":function(e,t,n){"use strict";var r=n("./node_modules/react/index.js"),a=n.n(r),i=function(e){console.warn("No <TracktorProvider /> setup.")};i.isDefault=!0;var c=i;i&&i===Object(i)&&Object.isExtensible(i)&&Object.defineProperty(i,"__filemeta",{enumerable:!0,configurable:!0,value:{name:"defaultDispatcher",filename:"src/utils/defaultDispatcher.ts"}}),n.d(t,"b",function(){return o}),n.d(t,"a",function(){return b});var o={data:{},dispatcher:c};"undefined"!==typeof o&&o&&o===Object(o)&&Object.isExtensible(o)&&Object.defineProperty(o,"__filemeta",{enumerable:!0,configurable:!0,value:{name:"initialState",filename:"src/TracktorContext.ts"}});var b=a.a.createContext(o);"undefined"!==typeof b&&b&&b===Object(b)&&Object.isExtensible(b)&&Object.defineProperty(b,"__filemeta",{enumerable:!0,configurable:!0,value:{name:"TracktorContext",filename:"src/TracktorContext.ts"}})},"./src/TracktorProvider.tsx":function(e,t,n){"use strict";var r=n("./node_modules/babel-preset-react-app/node_modules/@babel/runtime/helpers/esm/objectSpread.js"),a=n("./node_modules/react/index.js"),i=n.n(a),c=n("./src/TracktorContext.ts"),o=function(e){var t=e.children,n=e.dispatcher,a=Object(r.a)({},c.b,{dispatcher:n});return i.a.createElement(c.a.Consumer,null,function(e){return e.dispatcher.isDefault,i.a.createElement(c.a.Provider,{value:a},t)})};t.a=o,o&&o===Object(o)&&Object.isExtensible(o)&&Object.defineProperty(o,"__filemeta",{enumerable:!0,configurable:!0,value:{name:"TracktorProvider",filename:"src/TracktorProvider.tsx"}})}}]);
//# sourceMappingURL=docs-tracktor.e1b937a0f2fa2ea14f40.js.map